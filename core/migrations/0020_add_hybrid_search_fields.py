# Generated by Django 5.1.3 on 2026-01-23 03:50
# MODIFICADO: Migración segura para producción (no bloquea la base de datos)

import django.contrib.postgres.indexes
import django.contrib.postgres.search
from django.db import migrations

# Importar pgvector solo si está disponible
try:
    PGVECTOR_AVAILABLE = True
except ImportError:
    PGVECTOR_AVAILABLE = False


def add_embedding_field_if_available(apps, schema_editor):
    """
    Añade el campo embedding solo si pgvector está instalado.
    Si no está disponible, se salta silenciosamente.
    """
    if not PGVECTOR_AVAILABLE:
        print("⚠️  pgvector no disponible - campo embedding NO creado")
        print("   Instala pgvector y ejecuta esta migración nuevamente para habilitar búsqueda semántica")
        return
    
    # Verificar que la extensión vector existe en la base de datos
    with schema_editor.connection.cursor() as cursor:
        cursor.execute("SELECT EXISTS(SELECT 1 FROM pg_extension WHERE extname = 'vector')")
        vector_installed = cursor.fetchone()[0]
        
        if not vector_installed:
            print("⚠️  Extensión pgvector NO instalada en PostgreSQL")
            print("   Ejecuta: CREATE EXTENSION vector;")
            print("   O sigue las instrucciones en INSTALL_PGVECTOR.md")
            return
    
    # Si llegamos aquí, pgvector está disponible - crear campo
    Article = apps.get_model('core', 'Article')
    
    schema_editor.add_field(
        Article,
        Article._meta.get_field('embedding')
    )
    print("✅ Campo embedding creado correctamente")


class Migration(migrations.Migration):
    """
    Migración SEGURA para añadir campos de búsqueda híbrida.
    
    CAMPOS AÑADIDOS:
    - search_vector: Para búsqueda full-text con PostgreSQL (tsvector) - SIEMPRE
    - embedding: Para búsqueda semántica con pgvector (384 dimensiones) - SOLO SI PGVECTOR DISPONIBLE
    
    ÍNDICES:
    - GinIndex en search_vector: Se crea en esta migración con CONCURRENTLY
    - HnswIndex en embedding: Se crea MANUALMENTE después (ver create_hnsw_index.sql)
    
    IMPORTANTE: Esta migración NO bloquea la base de datos porque:
    1. Los campos permiten NULL (no requiere reescribir tabla)
    2. El índice GIN se crea CONCURRENTLY (no bloquea)
    3. El campo embedding solo se crea si pgvector está disponible
    """

    dependencies = [
        ('core', '0019_enable_pgvector_extensions'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='article',
            options={'ordering': ['-published_at']},
        ),
        
        # PASO 1: Añadir campo search_vector (SIEMPRE - no requiere pgvector)
        migrations.AddField(
            model_name='article',
            name='search_vector',
            field=django.contrib.postgres.search.SearchVectorField(
                blank=True, 
                help_text='Vector de búsqueda full-text precomputado (PostgreSQL tsvector)', 
                null=True
            ),
        ),
        
        # PASO 2: Crear índice GIN (normal en desarrollo, CONCURRENTLY en producción)
        # NOTA: En desarrollo usa migrations.AddIndex (bloquea pero es rápido)
        # NOTA: En producción ejecuta manualmente: CREATE INDEX CONCURRENTLY ...
        migrations.AddIndex(
            model_name='article',
            index=django.contrib.postgres.indexes.GinIndex(
                fields=['search_vector'],
                name='idx_article_search_vector'
            ),
        ),
    ]
    
    # INSTRUCCIONES PARA PRODUCCIÓN:
    # Para evitar bloqueo de tabla en producción, ejecutar manualmente:
    # psql -d legalwatchpr -c "CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_article_search_vector ON core_article USING GIN (search_vector);"
    # Luego ejecutar: python manage.py migrate --fake core 0020
